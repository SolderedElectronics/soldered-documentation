---
slug: /soldered-nula-beginner-kit.arduino/button-toggle-led
title: 2.1 Button Toggle LED
id: nula-beginner-arduino-button-toggle-led
hide_title: False
---

<CenteredImage src="/img/under_construction.png" alt="placeholder" caption="Full example video" width="600px"/>

The goal of this example is to teach you how to use the input mode of pins on the **Soldered NULA MINI** board. Inputs allow the board to react to external signals, such as buttons, switches, or sensors. In this case, we will use a **push button** as a simple input device to toggle the state of an LED. We wil also introduce the concept of **debouncing** and implement the said concept.

<SuccessBox>
**In this documentation you will learn:**
    - How to read a button state with `digitalRead()`.
    - What is **button debouncing** and how to handle it with `millis()`.
    - How to toggle an LED on each button press.
</SuccessBox>

**Hardware required:**
    - 1x Soldered NULA MINI board
    - 1x Breadboard
    - 1x Push button
    - 1x LED (any color)
    - 1x 330 ohm resistor
    - 1x 10k ohm resistor
    - Jumper wires
    - USB-c cable

<CenteredImage src="/img/nula-beginner-kit-arduino/2_1components.jpg" alt="All components" caption="All components needed for this example" />

---

## Putting the components together
We will start this example by connecting all the components. Just follow the steps provided below for a no hassle experience.

### 1. insert the NULA MINI board on the breadboard
<InfoBox>For this step you need to be familiar with the internal structure of a breadboard and its power rails. To familiarize, check out [**PLACEHOLDER**] documentation page.</InfoBox>

If your board has male connectors soldered to its pins, we recommend placing it on the breadboard to make it easier and tidyer for yourself to connect other components.

<CenteredImage src="/img/nula-beginner-kit-arduino/connection2_1_1.jpg" alt="USB connection" caption="Connecting the NULA MINI board to PC via USB-c cable." />


If not, no worry. You can just connect the board with components by wire. It will be a bit messier but will do the job just fine.


### 2. Connect the LED to the NULA MINI board
Take a piece of jumper wire and connect one end to an available GPIO pin on the board. For the needs of this example, we will be using **IO4** pin. Connect the other end to any free (meaning nothing is connected to it!) power rail on the breadboard.


<CenteredImage src="/img/nula-beginner-kit-arduino/connection2_1_2.jpg" alt="Step: 1" caption="Step: 1." />


Take one 330 ohm resistor and connect one end to the same power rail as the wire.Connect the other end of the resistor to some other free power rail. 

<CenteredImage src="/img/nula-beginner-kit-arduino/connection2_1_3.jpg" alt="Step: 2" caption="Step: 2." />

Take the LED and inspect its pins, there should be one longer than the other like this:

<CenteredImage src="/img/nula-beginner-kit-arduino/connection2_1_4.jpg" alt="Step: 3" caption="Step: 3." />

Connect the longer one (Anode) to the power rail that is connected to the other end of the 330 ohm resistor.

<CenteredImage src="/img/nula-beginner-kit-arduino/connection2_1_5.jpg" alt="Step: 4" caption="Step: 4." />

The shorter end of the LED (Cathode) needs to be connected to the **GND** pin on the NULA board.


### 3. Connect the Push button to the NULA MINI board  
Take a piece of jumper wire and connect one end to an available GPIO pin on the board. For this example, we will be using **IO19** pin. Connect the other end to any free (meaning nothing is connected to it!) power rail on the breadboard.  

<CenteredImage src="/img/nula-beginner-kit-arduino/connection2_1_6.jpg" alt="Step: 5" caption="Step: 5." />  

Connect one leg of the push button to the same power rail. On the opposite leg connect one side of the 10k ohm resistor, the other connect to **GND**.  

<CenteredImage src="/img/nula-beginner-kit-arduino/connection2_1_7.jpg" alt="Step: 6" caption="Step: 6." /> 

To the leg next to the one connected to **IO19** pin, connect the **3.3V** pin. The finished circuit should look something like this:  

<CenteredImage src="/img/nula-beginner-kit-arduino/connection2_1_8.jpg" alt="Step: 7" caption="Step: 7." /> 

<InfoBox>  
### What is a Pull-Down Resistor?  
When you connect a button directly to a pin on the **NULA MINI board**, the pin doesn’t always know if it should read as **HIGH** or **LOW** when the button is not pressed. In that “floating” state, the pin can randomly pick up electrical noise and switch between HIGH and LOW by itself, which leads to unreliable behavior.  

A **pull-down resistor** fixes this by gently “pulling” the pin’s value down to **LOW (0V)** whenever the button is not pressed. Think of it like a spring that always pulls the pin back to ground level when nothing else is happening.  

- When the button is **not pressed**, the resistor connects the pin to **GND**, so the NULA board reads **LOW**.  
- When the button **is pressed**, the button connects the pin directly to **3.3V**, and the board reads **HIGH**.  

The resistor value (commonly **10kΩ**) is chosen so it’s strong enough to keep the pin LOW when idle, but weak enough not to interfere when the button is pressed.  

Without a pull-down resistor, your button input may behave unpredictably, sometimes showing HIGH even when you are not pressing it.  
</InfoBox>  

---

## Reading the button state
To read the button state, we call `digitalRead()` function. Keep in mind that the pin needs to be set as an **INPUT** in order to use this function.

The function `digitalRead(pin)` reads the value from a specified digital pin and returns either **HIGH** or **LOW** as result. We call this function inside the **loop()**:

```cpp

void loop() {
  
  //digitalRead() is a function that reads the value from a specified digital pin, either HIGH or LOW.
  bool reading = digitalRead(BUTTON_PIN);
}
```

---

## Button debaouncing
When you press a button, it changes from an open circuit to a closed circuit, which we treat as a single press. For us, it feels like one clean action because we react slowly compared to electronics. But to a microcontroller, which checks the button state thousands of times in that short moment, it looks very different.

As the button is pushed, two metal contacts inside touch each other. Since they’re not perfectly smooth or aligned, they can quickly connect and disconnect a few times before settling. To the microcontroller, that looks like the button was pressed several times in a row, even though you only pressed it once.

<CenteredImage src="/img/nula-beginner-kit-arduino/button-debouncing-graph.png" alt="Button debouncing visualized" caption="Visualization of button debouncing" />

The simplest software-based strategy to handle this is the delay-based debouncer.
The whole point of it is to wait out the debouncing window. This is where the `millis()` comes in handy.

The function `millis()` returns the nuber of miliseconds passed since the board began running the current program. We can use it to check if enough time has passed between last button state change and current time, if it has, we are prepared for the next press, if not, wait a bit more.

This is a implementation example:

```cpp


//Those are the variables used for button debouncing.

bool ledState = false;
bool lastState = LOW;
unsigned long lastChangeMs = 0;
const unsigned long debounceMs = 25;

void setup() {

  /*
  pinMode() is a function that configures the specified pin to behave either as an input or in this case as an output.
  This simply means that the pin "listens" for the available data when in input mode, and "writes" data when in output mode.
  As our pin needs to detect if the button has been pressed, we will put the pin in INPUT mode.
  */
  pinMode(BUTTON_PIN, INPUT);  

}

void loop() {
  
  //digitalRead() is a function that reads the value from a specified digital pin, either HIGH or LOW.
  bool reading = digitalRead(BUTTON_PIN);

  /*
  millis() is a function that returns the number of milliseconds passed since the board began running the current program.
  In this example, we use this function to check out if the debouncing period has finnished. This number will overflow 
  (go back to zero), after approximately 50 days.
  */
  unsigned long now = millis();
 
  /*
  This is our debouncing logic, we check is the button has been pressed and if enough time has passed so that we dont get 
  false readings because of the noise in the signal.
  */
  if (reading != lastState && (now - lastChangeMs) > debounceMs) {
    lastChangeMs = now;

    //code that runs when the button is pressed...

    lastState = reading;
  }
}
```

---

## Toggling the LED
Each time a valid press is detected, we flip the LED's state with a simple toggle. This code is located inside the debouncer filter.

```cpp
if (lastState == LOW && reading == HIGH) {

      //We toggle the ledState
      ledState = !ledState;

      //We turn the LED on or off depending on the current ledState                
      if (ledState == true) {
        digitalWrite(LED_PIN, HIGH);
      } else {
        digitalWrite(LED_PIN, LOW);
      }
    }
    lastState = reading;
```

---
<CenteredImage src="/img/under_construction.png" alt="placeholder" caption="Full example video" width="600px"/>
---

## Full example
Check out the full example code on the link below:
<QuickLink 
  title="2.1_Button_Toggle_LED.ino" 
  description="Example that shows how to toggle LED light with a press of a button"
  url="https://github.com/SolderedElectronics/Soldered-NULA-Beginner-kit-Arduino-project-examples/blob/main/2_Inputs_and_Basic_interaction/2.1_Button_Toggle_LED/2.1_Button_Toggle_LED.ino" 
/>

